# seckill

## 系统介绍

使用SpringBoot开发的高并发抢购秒杀系统，实现了基本的登录、商品列表、商品详情、抢购秒杀、生成订单。

在此基础上，又对其进行了优化，分别为页面优化、接口优化、安全优化，来提高系统的并发承载能力。

## 技术栈

前端：Thymeleaf、Bootstrap、Jquery

后端：SpringBoot、MyBatisPlus、Lombok

中间件：RabbitMQ、Redis

## 基本功能实现

1. 用户登录
   * 两次MD5加密：前端对用户密码进行第一次加盐加密，防止在网络中的明文传输，后端再进行第二次加盐加密，避免通过MD5反推密码。
   * 分布式Session共享：使用UUID生成唯一id作为token，以token作为key，用户信息作为value存储到Redis中，解决了分布式情况下session不一致问题，并将token保存在cookie中，用来保存登录状态。

2. 全局异常
   * 定义全局异常类，处理系统中的各类自定义异常，便于错误定位，有利于维护。
3. 秒杀下单
   * 获取数据库商品库存，并减库存，然后再写回数据库，实现最简单的下单操作，但是当大量并发的情况下，会导致数据库压力过大，而且会产生超卖的情况。

## 页面优化

1. 页面缓存+对象缓存
   * 页面缓存：本系统最初采用Thymeleaf模板引擎开发，模板渲染耗时，首次渲染得到html页面并使用Redis进行缓存，加快了下次访问的速度。
   * 对象缓存：对用户信息、商品信息、订单信息等数据进行缓存，减少对数据库的访问。

2. 页面静态化
   * 使用html静态页面代替模板渲染，使用jquery+ajax异步请求实现静态数据和动态请求的分离，加快了页面的访问速度。

## 接口优化

1. Redis预减库存，在系统启动时就将数据库中待秒杀的商品库存加载到Redis中，在后续的秒杀中可以直接在Redis中进行操作，减少对数据库的访问。
2. 内存标记减少Redis的访问，当用户已经完成了对某个商品的秒杀时，使用ConcurrentHashMap进行标记，当重复抢购时不再需要访问Redis。
3. RabbitMQ异步下单，每次Redis预减库存后，都会产生一条抢购消息加入队列，之后再通过消费者对其进行数据库生成订单操作，来保护系统不会因高并发而奔溃，达到了削峰的作用。
4. 客户端轮询，当产生的抢购消息未被消费时，前端需要进入轮询结果的排队状态，当成功消费之后，再对用户返回订单详情的页面。
5. 通过拦截器在用户登录时获取用户信息，并存放到当前线程的ThreadLocal中，方便后续的使用

## 安全优化

1. 秒杀接口地址隐藏，为防止url请求地址暴露，用户恶意访问导致系统奔溃，前端不再直接访问秒杀接口，而是访问生成秒杀地址的接口，该接口生成随机path存入Redis并返回前端，前端拼接url访问秒杀接口，秒杀接口再根据传入的path与Redis中的进行比较来判断是否允许访问。

2. 算数验证码，用户在秒杀前需要先输入验证码，防止恶意的机器人和爬虫，并且能够将集中的秒杀请求分散，减轻了系统在短时间的压力。前端携带输入的验证码访问生成秒杀地址的接口，该接口将用户输入的验证码与Redis存放的正确验证码进行比较，判断是否可以进行秒杀操作。

3. 接口限流，使用Redis的过期时间以及原子减操作实现简单计数器限流算法，由于每个接口的流量限制不同，因此每个接口都需要实现限流逻辑，使用自定义注解来达到解耦的效果。

   通过向拦截器来获取每个请求的ip地址，并通过Redis的定时策略为每个ip地址计数，若是再指定时间内超过了流量限制，则拒绝该请求。

## 解决超卖

1. 对库存更新时，先判断库存是否大于0，只有当库存大于0时才能更新库存。
2. 在数据库层面上对用户id和商品id建立唯一索引，可以避免同一个用户同时发送两个请求并秒杀到两件相同的商品。
3. 对库存已经为空的商品进行内存标记，存放到一个HashMap中，多并发预减缓存前先检查HashMap中是否存在该商户id，如果是则表示该商品已售空，减少了Redis的访问。
4. Reids分布式锁解决超卖，使用lua脚本实现分布式锁，解决高并发秒杀的超卖问题。





